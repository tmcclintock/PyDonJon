import random
from typing import List, Optional, Type

from donjuan.cell import Cell, SquareCell
from donjuan.dungeon import Dungeon
from donjuan.grid import Grid
from donjuan.room import Room


class Randomizer:
    """
    Class for randomizing features of a dungeon.
    """

    def randomize_cell(self, cell: Cell) -> None:
        """Randomize properties of the `Cell`"""
        pass  # pragma: no cover

    def randomize_dungeon(self, dungeon: Dungeon) -> None:
        """Randomize properties of the `Dungeon`"""
        pass  # pragma: no cover

    def randomize_grid(self, grid: Grid) -> None:
        """Randomize properties of the `Grid`"""
        pass  # pragma: no cover

    def randomize_room(self, room: Room) -> None:
        """Randomize properties of the `Room`"""
        pass  # pragma: no cover

    @classmethod
    def seed(cls, seed: Optional[int] = None) -> None:
        """
        Args:
            seed (Optional[int]): seed passed to :meth:`random.seed`
        """
        random.seed(seed)


class RandomFilled(Randomizer):
    """
    Randomly set the :attr:`filled` attribute of cells.
    """

    def randomize_cell(self, cell: Cell) -> None:
        """Randomly fill the cell with probability 50%"""
        cell.filled = bool(random.randint(0, 1))

    def randomize_grid(self, grid: Grid) -> None:
        """Randomly fill all cells of the grid individually"""
        for i in range(grid.n_rows):
            for j in range(grid.n_cols):
                self.randomize_cell(grid.cells[i][j])
        return


class RoomRandomizer(Randomizer):
    """
    Randomize the features of a `Room`.
    """

    def __init__(
        self, min_size: int = 2, max_size: int = 4, cell_type: Type[Cell] = SquareCell
    ):
        super().__init__()
        assert issubclass(cell_type, Cell)
        assert min_size >= 1, f"{min_size}"
        assert max_size >= min_size, f"{max_size} < {min_size}"
        assert max_size <= 100, f"{max_size}"  # arbitrary
        self.min_size = min_size
        self.max_size = max_size
        self.cell_type = cell_type

    def randomize_room(self, room: Room) -> None:
        """
        Randomly determine the size of the room, and set the cells of
        the room to a 2D array of unfilled cells of that size.
        """
        # Draw the dimensions
        height = random.randint(self.min_size, self.max_size)
        width = random.randint(self.min_size, self.max_size)

        # Create empty cells and set them in the room
        cells = [
            [self.cell_type(filled=False, coordinates=(i, j)) for j in range(height)]
            for i in range(width)
        ]
        room.set_cells(cells)
        return


class DungeonRoomRandomizer(Randomizer):
    """
    Randomize a dungeon by first creating rooms and then applying
    :meth:`RoomRandomizer.room_randomize` to them.

    Args:
        room_randomizers (Optional[List[RoomRandomizer]]): randomizers to
            to apply to each room generated by this randomizer
        max_num_rooms (Optional[int]): maximum number of rooms to draw,
            if ``None` then default to the :attr:`max_room_attempts`. See
            :meth:`DungeonRoomRandomizer.get_number_of_rooms` for details.
        max_room_attempts (int, optional): default is 100. Maximum number of
            attempts to generate rooms.
    """

    def __init__(
        self,
        room_randomizers: Optional[List[RoomRandomizer]] = None,
        max_num_rooms: Optional[int] = None,
        max_room_attempts: int = 100,
    ):
        super().__init__()
        self.room_randomizers = room_randomizers or [RoomRandomizer()]
        for room_randomizer in self.room_randomizers:
            assert isinstance(room_randomizer, RoomRandomizer)
        self.max_num_rooms = max_num_rooms or max_room_attempts
        self.max_room_attempts = max_room_attempts

    def get_number_of_rooms(self, dungeon_n_rows: int, dungeon_n_cols: int) -> int:
        """
        Randomly determine the number of rooms based on the size
        of the incoming grid or the :attr:`max_num_rooms` attribute,
        whichever is less.

        Args:
            dungeon_n_rows (int): number of rows
            dungeon_n_cols (int): number of columns
        """
        # Loop over room randomizers to find the one with the max `max_size`
        max_size = 1
        for room_randomizer in self.room_randomizers:
            if hasattr(room_randomizer, "max_size"):
                max_size = max(max_size, room_randomizer.max_size)
        dungeon_area = dungeon_n_rows * dungeon_n_cols
        max_room_area = max_size ** 2
        return min(self.max_num_rooms, dungeon_area // max_room_area)

    def randomize_dungeon(self, dungeon: Dungeon) -> None:
        """
        Randomly put rooms in the dungeon.

        .. todo:: Make a `Labeler` object.

        .. todo:: Offload the room shift logic to a different randomizer.

        Args:
            dungeon (Dungeon): dungeon to randomize the rooms of
        """
        # Compute then umber
        n_rooms = self.get_number_of_rooms(dungeon.n_rows, dungeon.n_cols)

        # Create rooms, randomize, and check for overlap
        i = 0
        label = 0
        while len(dungeon.rooms) < n_rooms:
            # Create the room and randomize
            room = Room(name=label)
            for room_randomizer in self.room_randomizers:
                room_randomizer.randomize_room(room)

            # Draw random positions and shift
            room.shift_horizontal(random.randint(0, dungeon.n_cols - room.n_cols))
            room.shift_vertical(random.randint(0, dungeon.n_rows - room.n_rows))

            overlaps = False
            for existing_room_id, existing_room in dungeon.rooms.items():
                if room.overlaps(existing_room):
                    overlaps = True
                    break

            if not overlaps:
                dungeon.add_room(room)
                label += 1

            # Check for max attempts
            i += 1
            if i == self.max_room_attempts:
                break
        return
